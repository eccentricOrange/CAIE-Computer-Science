---
nav_order: 0
---

# Dealing with computer science

## Breaking down conventions
Most <abbr title="Computer Science">CS</abbr> syllabuses at high school have two major components.

* **Problem-solving and programming**

    Typically, this includes some general ideas of how to approach a problem: breaking it down, writing a problem-statement, making a flowchart ,writing pseudocode et cetera. The other major part will be some kind of programming, usually with one language (like Python). Often, there will be some section on databases (<abbr title="Structured Query Language">SQL</abbr> or Access?) too.

* **Theory**

    There are two kinds of topics in theory sections, some drier than others. One major chunk (that students often find frustrating) is about different devices, rules, protocols, hardware et cetera; think printers, input/output devices, advantages/disadvantages and so on. The other part is more applied: logic gates, assembly programming, theory of databases and such.

I'd argue it's a good idea to group it into three categories, because this allows you to plan your studies better. The rest of this guide explains how to leverage that

* **Applied logic and problem-solving**

    In this section, I'm taking out just the "thinking" part from both of the conventional sections. So this is about being able to read a problem and think of a solution, about breaking down a logic statement into gates, understanding what assembly instructions do, using a <abbr title="DataBase Management System">DBMS</abbr>, and so on. This tends to be the most interesting part of CS, so if you're disinterested/demotivated, start here.

* **Writing and communication**

    The aspects that distinguish an exam from real-life applications. Here, we tackle ways represent your ideas as flowcharts, programming languages, pseudocode, database relation diagrams, class diagrams etc.

* **Theory**

    This is collecting together the stuff that people typically find boring. It's about different devices, rules, protocols, hardware et cetera; think printers, input/output devices, advantages/disadvantages and so on.


## What's the overall approach?
In general, my approach to learn something is to make it useful. In fact, I mostly learnt CS concepts as I needed them, instead of relying on when a book presented them to me. So that's what we'll do. Instead of starting with a syllabus, we'll start with applications. Everywhere. It's going to be a little different from what you think when you think studies (books, notes, exams).

## Develop applied logic and problem-solving skills
> So, how do we make this useful?

We are able to do that when we experience a need for it. There are two approaches to developing one:

* If you want something, and have an intuition that a skill like coding would let you build it. For example, I recently wrote a program to automatically check answers to my <abbr title="Multiple Choice Questions">MCQ</abbr> papers, assign a syllabus grade to sets of practice papers, and give me an updated list of my strengths and weaknesses as I practice more papers.

    In such a case, the most straight forward way is to follow the problem-solving process, and just get to it. There were a lot of things I struggled with (such as, how do you make a program read a grade threshold table available as a PDF document?), but they were easily solvable with a few Google/YouTube search queries. Turns out, I'm usually not the first one to run into most problems (even the seemingly obscure ones), and someone would have explained in good detail how it works, maybe even written up a plug-and-play chunk of code (a library/module).

* If you want someone to provide you with a problem, you are in luck if you're trying to study for an exam. Usually, there will be some project(s) you have to complete. Try to pick up one of these, and just get started with it. You may not have studied the syllabus, and that's okay. The point here is to develop a need for doing so. Spend some time with it. Break it down into really tiny problems, and then [ask around](https://eccentricorange.github.io/CAIE-Computer-Science/things-to-know.html#asking-for-help): ask teachers/peers, Google, use online forums, use YouTube, read textbooks. You'll get a good idea of what you can do and what you cannot yet.

    You don't need to finish the whole thing this way though. Just enough that you know what you need to study.

> Well, that's all hunky-dory, but how on earth do I assess what I know or don't know without knowing what's in the syllabus?

Spend a day or two just messing with the syllabus specification (or textbook, or whatever way it has been presented to you) and Googling stuff you don't understand. You would learn the capabilities of your course. For example, you may not understand the difference between a while loop and a for loop, and may not understand their syntax, but you'd learn that repeatedly executing a given chunk of code is possible.

